use crate::primitives::{Expression, BinaryOpType, UnaryOpType};
use std::rc::Rc;

grammar;

pub Expr: Rc<Expression>  = {
      OrExpr,
};


OrExpr: Rc<Expression> = {
    <left_op: OrExpr> "or" <right_op: AndExpr>
        => Rc::new(Expression::BinaryOp(left_op.clone(), BinaryOpType::LogicalOr, right_op.clone())),
    AndExpr,
};

AndExpr: Rc<Expression> = {
    <left_op: AndExpr> "and" <right_op: NotExpr>
        => Rc::new(Expression::BinaryOp(left_op.clone(), BinaryOpType::LogicalAnd, right_op.clone())),
    NotExpr,
};

NotExpr: Rc<Expression> = {
    "not" <op: NotExpr>
        => Rc::new(Expression::UnaryOp(UnaryOpType::LogicalNot, op.clone())),
    CmpExpr,
};

CmpExpr: Rc<Expression> = {
    <left_op: CmpExpr> <operator: CmpOperator> <right_op: BitwiseOrExpr>
         => Rc::new(Expression::BinaryOp(left_op.clone(), operator, right_op.clone())),
    BitwiseOrExpr,
};

BitwiseOrExpr: Rc<Expression> = {
    <left_op: BitwiseOrExpr> "|" <right_op: BitwiseAndExpr>
         => Rc::new(Expression::BinaryOp(left_op.clone(),  BinaryOpType::BitwiseOr, right_op.clone())),
    BitwiseAndExpr,
};


BitwiseAndExpr: Rc<Expression> = {
    <left_op: BitwiseAndExpr> "&" <right_op: ShiftExpr>
         => Rc::new(Expression::BinaryOp(left_op.clone(),  BinaryOpType::BitwiseAnd, right_op.clone())),
    ShiftExpr,
};

ShiftExpr: Rc<Expression> = {
    <left_op: ShiftExpr> <operator: ShiftOperator> <right_op: SumExpr>
         => Rc::new(Expression::BinaryOp(left_op.clone(),  operator, right_op.clone())),
    SumExpr,
};

SumExpr: Rc<Expression> = {
    <left_op: SumExpr> "+" <right_op: ProdExpr>
        => Rc::new(Expression::BinaryOp(left_op.clone(), BinaryOpType::Sum, right_op.clone())),
    <left_op: SumExpr> "-" <right_op: ProdExpr>
        => Rc::new(Expression::BinaryOp(left_op.clone(), BinaryOpType::Subtract, right_op.clone())),
    ProdExpr,
};

ProdExpr: Rc<Expression> = {
    <left_op: ProdExpr> "*" <right_op: AtomExpr>
        => Rc::new(Expression::BinaryOp(left_op.clone(), BinaryOpType::Product, right_op.clone())),
    <left_op: ProdExpr> "/" <right_op: AtomExpr>
        => Rc::new(Expression::BinaryOp(left_op.clone(), BinaryOpType::Divide, right_op.clone())),
    <left_op: ProdExpr> "//" <right_op: AtomExpr>
        => Rc::new(Expression::BinaryOp(left_op.clone(), BinaryOpType::FloorDiv, right_op.clone())),
    <left_op: ProdExpr> "%" <right_op: AtomExpr>
        => Rc::new(Expression::BinaryOp(left_op.clone(), BinaryOpType::Modulo, right_op.clone())),
    UnaryExpr,
};

UnaryExpr: Rc<Expression> = {
    "-" <op: UnaryExpr>  => Rc::new(Expression::UnaryOp(UnaryOpType::Minus, op.clone())),
    "~" <op: UnaryExpr>  => Rc::new(Expression::UnaryOp(UnaryOpType::BitwiseNot, op.clone())),
    "+" <op: UnaryExpr>  => op,
    ExponentExpr,
};

ExponentExpr: Rc<Expression> = {
    <left_op: AtomExpr> "**" <right_op: ExponentExpr>
        => Rc::new(Expression::BinaryOp(left_op.clone(), BinaryOpType::Exponent, right_op.clone())),
    AtomExpr,
};

AtomExpr: Rc<Expression> = {
    <identifier: Identifier>                                    => Rc::new(Expression::Variable(identifier)),
    <call: AtomExpr> "(" <commaed_exprs: CommaedExprsFinal> ")" => Rc::new(Expression::Call(call.clone(), commaed_exprs)),
    <call: AtomExpr> "("  ")"                                   => Rc::new(Expression::Call(call.clone(), vec![])),
    "(" <expr: Expr> ")"                                        => expr,
};

CommaedExprs: Vec<Rc<Expression>> = {
    <commaed_exprs: CommaedExprs> "," <expr: Expr>             => [commaed_exprs.as_slice(), vec![expr].as_slice()].concat(),
    <expr: Expr>                                               => vec![expr],
}

CommaedExprsFinal: Vec<Rc<Expression>> = {
    <commaed_exprs: CommaedExprs>      => commaed_exprs,
    <commaed_exprs: CommaedExprs> ","  => commaed_exprs,
};

CmpOperator: BinaryOpType = {
    "==" => BinaryOpType::Equal,
    "!=" => BinaryOpType::NotEqual,
    ">"  => BinaryOpType::Greater,
    ">=" => BinaryOpType::GreaterEqual,
    "<"  => BinaryOpType::Less,
    "<=" => BinaryOpType::LessEqual,
};

ShiftOperator: BinaryOpType = {
    ">>" => BinaryOpType::RightShift,
    "<<" => BinaryOpType::LeftShift,
};

Identifier: String =  {
    <s:r"[a-zA-Z_][a-zA-Z0-9_]*"> => s.to_string(),
};